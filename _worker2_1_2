import { connect } from 'cloudflare:sockets';

// ==================== ① 基础配置 ====================
let userID = ''; // 请自行替换
let proxyIP = 'proxyip.cmliussss.net'; // 默认代理，可被 path/query 覆盖

// 并发回源参数：直连优先，超过该延迟无下行则并发代理
const FALLBACK_DELAY_MS = 400;

// 背压与缓冲参数
const WS_BUFFERED_THRESHOLD = 512 * 1024; // 触发背压阈值
const WS_BUFFERED_RESUME = 256 * 1024;    // 背压恢复阈值
const WS_BUFFERED_CHECK_INTERVAL_MS = 6;  // 背压轮询间隔
const MAX_BUFFER_BEFORE_RACE = 256 * 1024; // 选路前 WS→远端缓冲上限

// 预设优选域名（保持原有列表）
const preferredDomains = [
    'store.ubi.com',
    'ip.sb',
    'mfa.gov.ua',
    'shopify.com',
    'cloudflare-dl.byoip.top',
    'staticdelivery.nexusmods.com',
    'bestcf.top',
    'cf.090227.xyz',
    'cf.zhetengsha.eu.org',
    'baipiao.cmliussss.abrdns.com',
    'saas.sin.fan',
];

// ==================== ② 代理信息解析（纯函数） ====================
let proxyConfig = { proxyHost: '', proxyPort: null };
function parseProxyIP(inputProxyIP) {
    proxyConfig = { proxyHost: '', proxyPort: null };
    if (!inputProxyIP) return;
    const parts = inputProxyIP.split(':');
    proxyConfig.proxyHost = parts[0].trim();
    if (parts.length > 1) {
        const p = parseInt(parts[1].trim(), 10);
        if (!isNaN(p) && p > 0 && p <= 65535) proxyConfig.proxyPort = p;
    }
}

// ==================== ③ 工具函数 ====================
// 从路径提取 /proxyip=...（可带后续段）
function extractProxyFromPath(pathname) {
    const m = /^\/proxyip=([^/]+)(?:\/.*)?$/.exec(pathname);
    return m ? m[1] : null;
}
// 计算本次请求生效的 proxyip
function getEffectiveProxyIP(url) {
    const fromQuery = (url.searchParams.get('proxyip') || '').trim();
    const fromPath = extractProxyFromPath(url.pathname);
    return fromQuery || fromPath || proxyIP;
}

// base64 → Uint8Array
function base64ToArrayBuffer(base64Str) {
    if (!base64Str) return { error: null };
    try {
        const b64 = base64Str.replace(/-/g, '+').replace(/_/g, '/');
        const dec = atob(b64);
        const u8 = Uint8Array.from(dec, c => c.charCodeAt(0));
        return { earlyData: u8.buffer, error: null };
    } catch (e) {
        return { error: e };
    }
}

// 复用解码器，避免频繁创建
const TEXT_DECODER = new TextDecoder();

// UUID 检验 & 字符串化（保持原实现）
function isValidUUID(uuid) {
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    return uuidRegex.test(uuid);
}
const byteToHex = [];
for (let i = 0; i < 256; ++i) byteToHex.push((i + 256).toString(16).slice(1));
function unsafeStringify(arr, offset = 0) {
    return (
        byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" +
        byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" +
        byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" +
        byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" +
        byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] +
        byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]
    ).toLowerCase();
}
function stringify(arr, offset = 0) {
    const uuid = unsafeStringify(arr, offset);
    if (!isValidUUID(uuid)) throw TypeError('Stringified UUID is invalid');
    return uuid;
}

// ==================== ④ VLESS 配置生成（path 显示当前 proxyip） ====================
function getVLESSConfig(userID, currentHost, proxyHostPort) {
    const protocol = 'vless';
    const path = `/proxyip=${proxyHostPort}`;
    const params = new URLSearchParams({
        encryption: 'none',
        security: 'tls',
        sni: currentHost,
        fp: 'chrome',
        type: 'ws',
        host: currentHost,
        path: path, // 以 /proxyip=... 的形式
    });

    const allVlessUris = preferredDomains.map((domain, idx) => {
        const alias = `T-SNIP_${String(idx + 1).padStart(2, '0')}`;
        return `${protocol}://${userID}@${domain}:443?${params.toString()}#${alias}`;
    });

    const sub = allVlessUris.join('\n');
    // URL‑Safe Base64，直接可用于订阅链接
    return btoa(sub).replace(/\+/g, '-').replace(/\//g, '_');
}

// ==================== ⑤ 主入口 ====================
if (!isValidUUID(userID)) {
    throw new Error('uuid is not valid');
}

export default {
    async fetch(request, env, ctx) {
        try {
            const url = new URL(request.url);

            // 计算本次请求的生效 proxyip，并设置到全局 proxyConfig
            const effectiveProxyIP = getEffectiveProxyIP(url);
            parseProxyIP(effectiveProxyIP);

            // 解析路径中的 UUID（支持 /UUID 与 /proxyip=.../UUID）
            let pathUUID = null;
            const pm = /^\/proxyip=([^/]+)(?:\/([0-9a-f-]{36}))?$/.exec(url.pathname);
            if (pm && pm[2]) {
                pathUUID = pm[2];
            } else if (url.pathname.length > 1) {
                pathUUID = url.pathname.substring(1);
            }

            const upgradeHeader = request.headers.get('Upgrade');
            if (!upgradeHeader || upgradeHeader !== 'websocket') {
                // ---------- 非 WebSocket ----------
                if (url.pathname === '/') {
                    return new Response('恭喜你快成功了，快去添加 UUID 并可用 ?proxyip= 覆盖代理', {
                        status: 200,
                        headers: { 'Content-Type': 'text/plain;charset=utf-8' },
                    });
                }
                if (pathUUID && pathUUID === userID) {
                    const cfg = getVLESSConfig(pathUUID, request.headers.get('Host'), effectiveProxyIP);
                    return new Response(cfg, {
                        status: 200,
                        headers: { 'Content-Type': 'text/plain;charset=utf-8' },
                    });
                }
                return new Response('请填写正确的 UUID', {
                    status: 400,
                    headers: { 'Content-Type': 'text/plain;charset=utf-8' },
                });
            }

            // ---------- WebSocket ----------
            return await vlessOverWSHandler(request);
        } catch (err) {
            return new Response(err.toString(), {
                status: 500,
                headers: { 'Content-Type': 'text/plain;charset=utf-8' },
            });
        }
    },
};

// ==================== ⑥ WebSocket 处理（低拷贝 + 背压 + 有界缓冲） ====================
async function vlessOverWSHandler(request) {
    // 确保 WS 连接时也根据 path/query 设置代理
    const url = new URL(request.url);
    const effProxy = getEffectiveProxyIP(url);
    parseProxyIP(effProxy);

    const pair = new WebSocketPair();
    const [client, server] = Object.values(pair);
    server.accept();

    const earlyDataHeader = request.headers.get('sec-websocket-protocol') || '';
    const readableWS = makeReadableWebSocketStream(server, earlyDataHeader);

    let remote = {
        value: null,
        writer: null,
        ready: false,
        buffered: [],
        bufferedBytes: 0,
        _triggerProxy: null,
        _active: false,
    };
    let udpWrite = null;
    let isDns = false;
    let handshakeDone = false;

    readableWS.pipeTo(new WritableStream({
        async write(chunk) {
            // 1) 已判断为 DNS：直接走 UDP 写入
            if (isDns && udpWrite) {
                udpWrite(chunk);
                return;
            }

            // 2) 已握手：根据选路状态写或缓冲
            if (handshakeDone) {
                if (remote.ready && remote.writer) {
                    await remote.writer.write(chunk);
                } else {
                    remote.buffered.push(chunk);
                    remote.bufferedBytes += chunk.byteLength || chunk.length || 0;
                    if (remote.bufferedBytes > MAX_BUFFER_BEFORE_RACE && typeof remote._triggerProxy === 'function') {
                        remote._triggerProxy(); // 缓冲过大，提前并发代理
                    }
                }
                return;
            }

            // 3) 首包：解析 VLESS 头部并决定 TCP/UDP 流程
            const {
                hasError,
                message,
                portRemote = 443,
                addressRemote = '',
                rawDataIndex,
                vlessVersion = new Uint8Array([0, 0]),
                isUDP,
            } = processVlessHeader(chunk, userID);
            if (hasError) throw new Error(message);

            handshakeDone = true;

            // 只允许 DNS UDP（53）
            if (isUDP) {
                const port = portRemote;
                if (port === 53) {
                    isDns = true;
                } else {
                    throw new Error('UDP proxy only enable for DNS which is port 53');
                }
            }

            const vlessRespHeader = new Uint8Array([vlessVersion[0], 0]); // VLESS reply
            const rawClient = chunk.slice(rawDataIndex);

            if (isDns) {
                const { write } = await handleUDPOutBound(server, vlessRespHeader);
                udpWrite = write;
                udpWrite(rawClient);
                return;
            }

            // TCP：开启“直连优先 + 定时并发代理竞速”
            handleTCPOutBoundFast(remote, addressRemote, portRemote, rawClient, server, vlessRespHeader);
        },
    })).catch(() => { /* 内部已处理 */ });

    return new Response(null, { status: 101, webSocket: client });
}

// ==================== ⑦ 可读 WebSocket 流 ====================
function makeReadableWebSocketStream(ws, earlyDataHeader) {
    let cancelled = false;
    const { earlyData, error } = base64ToArrayBuffer(earlyDataHeader);
    if (error) console.warn('early‑data decode error:', error);

    return new ReadableStream({
        start(controller) {
            if (earlyData) controller.enqueue(new Uint8Array(earlyData));

            ws.addEventListener('message', e => {
                if (cancelled) return;
                controller.enqueue(e.data);
            });
            ws.addEventListener('close', () => {
                safeCloseWebSocket(ws);
                if (!cancelled) controller.close();
            });
            ws.addEventListener('error', err => controller.error(err));
        },
        cancel() {
            cancelled = true;
            safeCloseWebSocket(ws);
        },
    });
}

// ==================== ⑧ VLESS Header 解析（防越界） ====================
function processVlessHeader(buf, userID) {
    try {
        if (buf.byteLength < 24) throw new Error('invalid data');

        const version = new Uint8Array(buf.slice(0, 1));

        const uuidStr = stringify(new Uint8Array(buf.slice(1, 17)));
        if (uuidStr !== userID.toLowerCase()) throw new Error('invalid user');

        const optLen = new Uint8Array(buf.slice(17, 18))[0];
        const cmdIdx = 18 + optLen;
        const cmd = new Uint8Array(buf.slice(cmdIdx, cmdIdx + 1))[0];
        const isUDP = cmd === 2;
        if (cmd !== 1 && !isUDP) throw new Error(`unsupported command ${cmd}`);

        const portIdx = cmdIdx + 1;
        if (buf.byteLength < portIdx + 2) throw new Error('missing port');
        const port = new DataView(buf.slice(portIdx, portIdx + 2)).getUint16(0);

        let addrIdx = portIdx + 2;
        if (buf.byteLength < addrIdx + 1) throw new Error('missing address type');
        const addrType = new Uint8Array(buf.slice(addrIdx, addrIdx + 1))[0];
        addrIdx += 1;

        let addr = '', addrLen = 0;
        switch (addrType) {
            case 1: // IPv4
                addrLen = 4;
                if (buf.byteLength < addrIdx + addrLen) throw new Error('incomplete IPv4');
                addr = new Uint8Array(buf.slice(addrIdx, addrIdx + addrLen)).join('.');
                break;
            case 2: // Domain
                addrLen = new Uint8Array(buf.slice(addrIdx, addrIdx + 1))[0];
                addrIdx += 1;
                if (buf.byteLength < addrIdx + addrLen) throw new Error('incomplete domain');
                addr = TEXT_DECODER.decode(buf.slice(addrIdx, addrIdx + addrLen));
                break;
            case 3: // IPv6
                addrLen = 16;
                if (buf.byteLength < addrIdx + addrLen) throw new Error('incomplete IPv6');
                const dv = new DataView(buf.slice(addrIdx, addrIdx + addrLen));
                const parts = [];
                for (let i = 0; i < 8; i++) parts.push(dv.getUint16(i * 2).toString(16));
                addr = parts.join(':');
                break;
            default:
                throw new Error(`invalid addressType ${addrType}`);
        }

        const rawIdx = addrIdx + addrLen;
        return {
            hasError: false,
            addressRemote: addr,
            portRemote: port,
            rawDataIndex: rawIdx,
            vlessVersion: version,
            isUDP,
        };
    } catch (e) {
        return { hasError: true, message: e.message };
    }
}

// ==================== ⑨ TCP 并发竞速 + 背压 + 冲刷 ====================
async function handleTCPOutBoundFast(remoteWrapper, address, port, initData, ws, vlessHeader) {
    if (remoteWrapper._active) return;
    remoteWrapper._active = true;

    let selected = null; // 'direct' | 'proxy'
    let headerPending = vlessHeader ? vlessHeader.slice(0) : null;
    let directSock = null;
    let proxySock = null;
    let fallbackTimer = null;
    let closed = false;
    let proxyStarted = false;

    function clearFallbackTimer() {
        if (fallbackTimer) {
            try { clearTimeout(fallbackTimer); } catch {}
            fallbackTimer = null;
        }
    }

    // 背压检测
    function wsBufferedAmount(ws) {
        const v = ws && typeof ws.bufferedAmount === 'number' ? ws.bufferedAmount : 0;
        return v | 0;
    }
    function sleep(ms) {
        return new Promise(r => setTimeout(r, ms));
    }
    async function waitWSDrainIfNeeded() {
        if (wsBufferedAmount(ws) < WS_BUFFERED_THRESHOLD) return;
        while (ws.readyState === WS_READY_STATE_OPEN && wsBufferedAmount(ws) > WS_BUFFERED_RESUME) {
            await sleep(WS_BUFFERED_CHECK_INTERVAL_MS);
        }
    }

    async function sendToWS(chunk) {
        if (ws.readyState !== WS_READY_STATE_OPEN) throw new Error('WebSocket not open');
        if (headerPending) {
            // 首次先发送 VLESS 回包头，避免合并拷贝
            ws.send(headerPending);
            headerPending = null;
        }
        // 背压：当缓冲过大时暂停读取与发送，降低内存占用
        await waitWSDrainIfNeeded();
        ws.send(chunk);
    }

    async function startReader(sock, label) {
        const reader = sock.readable.getReader();
        try {
            while (true) {
                const { value, done } = await reader.read();
                if (done) break;
                if (closed) break;

                // 首次赢者
                if (!selected) {
                    selected = label;
                    clearFallbackTimer();

                    // 选定写入方向：复用单一 writer
                    remoteWrapper.value = sock;
                    remoteWrapper.writer = sock.writable.getWriter();

                    // 冲刷 WS->远端 的已缓冲数据
                    const pending = remoteWrapper.buffered || [];
                    if (pending.length) {
                        for (const buf of pending) {
                            await remoteWrapper.writer.write(buf);
                        }
                        pending.length = 0;
                        remoteWrapper.bufferedBytes = 0;
                    }
                    remoteWrapper.ready = true;

                    // 关闭败者
                    try {
                        if (label === 'direct' && proxySock) proxySock.close();
                        if (label === 'proxy' && directSock) directSock.close();
                    } catch {}
                } else if (selected !== label) {
                    // 已有赢家，直接关闭当前
                    try { sock.close(); } catch {}
                    break;
                }

                // 将远端下行写回 WS（带背压控制）
                await sendToWS(value);
            }
        } catch {
            // 读取异常忽略
        } finally {
            try { reader.releaseLock(); } catch {}
            // 若赢家的流结束，关闭 WS
            if (selected === label && !closed) {
                closed = true;
                safeCloseWebSocket(ws);
            }
        }
    }

    // 直连优先：启动直连并发送首包
    directSock = connect({ hostname: address, port });
    try {
        const w = directSock.writable.getWriter();
        await w.write(initData);
        w.releaseLock();
    } catch { /* 写入异常无妨，读侧处理 */ }
    startReader(directSock, 'direct');

    // 定义立即启动代理的函数（供缓冲过大时触发）
    async function startProxyNow() {
        if (proxyStarted || !proxyConfig.proxyHost) return;
        proxyStarted = true;
        try {
            proxySock = connect({
                hostname: proxyConfig.proxyHost,
                port: proxyConfig.proxyPort !== null ? proxyConfig.proxyPort : port,
            });
            const w2 = proxySock.writable.getWriter();
            await w2.write(initData);
            w2.releaseLock();
            startReader(proxySock, 'proxy');
        } catch {
            // 代理启动失败，保持直连
        }
    }
    remoteWrapper._triggerProxy = startProxyNow;

    // 定时启动并发代理（若未提前触发）
    if (proxyConfig.proxyHost) {
        fallbackTimer = setTimeout(() => {
            if (selected || closed) return;
            startProxyNow();
        }, FALLBACK_DELAY_MS);
    }
}

// ==================== ⑩ DNS（UDP）处理 – DoH，首包头独立发送 ====================
async function handleUDPOutBound(ws, vlessHeader) {
    let sentHeader = false;

    const transform = new TransformStream({
        transform(chunk, controller) {
            // 拆分为若干 UDP 包（len + payload）
            for (let i = 0; i < chunk.byteLength;) {
                const len = new DataView(chunk.buffer, chunk.byteOffset + i, 2).getUint16(0);
                const data = new Uint8Array(chunk.buffer, chunk.byteOffset + i + 2, len);
                controller.enqueue(data);
                i += 2 + len;
            }
        },
    });

    transform.readable.pipeTo(new WritableStream({
        async write(dQuery) {
            const resp = await fetch('https://dns.google/dns-query', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/dns-message',
                    'Accept': 'application/dns-message',
                },
                body: dQuery,
            });
            const ans = new Uint8Array(await resp.arrayBuffer());
            const sz = ans.byteLength;
            const szBuf = new Uint8Array([(sz >> 8) & 0xff, sz & 0xff]);

            if (ws.readyState === WS_READY_STATE_OPEN) {
                if (!sentHeader) {
                    ws.send(vlessHeader); // 头单独发，避免拷贝
                    sentHeader = true;
                }
                // 长度与数据分帧发送，免去拼接拷贝
                ws.send(szBuf);
                ws.send(ans);
            }
        },
    })).catch(() => { /* 吞掉错误即可 */ });

    const writer = transform.writable.getWriter();

    return {
        write(chunk) {
            writer.write(chunk);
        },
    };
}

// ==================== ⑪ 辅助：WebSocket 安全关闭 ====================
const WS_READY_STATE_OPEN = 1;
const WS_READY_STATE_CLOSING = 2;
function safeCloseWebSocket(sock) {
    try {
        if (sock.readyState === WS_READY_STATE_OPEN || sock.readyState === WS_READY_STATE_CLOSING) {
            sock.close();
        }
    } catch { /* ignore */ }
}
